hpp:
#ifndef phonebook_hpp_
#define phonebook_hpp_

#include <string>
#include <vector>
#include <list>
#include <unordered_map>
#include <map>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <functional>
#include <unordered_set>
#include <set>
#include <deque>
#include <memory>


class phonebook
{
public:
	struct person_entry
	{
		using phone_list = std::deque< std::string>;

		std::string first_name;
		std::string last_name;
		std::string dept;
		phone_list phones;
	};
	//using ptr_t = std::unique_ptr<person_entry>;
	std::size_t quantity = 0;
	std::vector<person_entry> entries;
	std::size_t count_delete = 0;



	using person_handle = std::size_t;


	using storing_handle = std::map<person_handle, std::shared_ptr<person_entry>>;

	using person_handle_list = std::vector<person_handle>;

	storing_handle person_hl;


	std::multimap<std::string, person_handle> Department;

	std::multimap<std::string, person_handle> LastNamePrefix;



	enum dept_filter
	{
		any_dept,
		dept_equal,
		dept_substring
	};

	enum last_name_filter
	{
		any_last_name,
		last_name_prefix
	};

	person_handle_list find(
		dept_filter p_dept,
		const std::string& s_dept,
		last_name_filter p_last_name,
		const std::string& s_last_name);

	const person_entry& get_person_entry(person_handle h) const;

	person_handle add_person(const person_entry& z);

	void add_phone(person_handle h, const std::string& phone);

	void remove_phone(person_handle h, const std::string& phone);

	void change_last_name(person_handle h, const std::string& last_name);

	void change_dept(person_handle h, const std::string& dept);

	void remove_person(person_handle h);
};

#endif

/**/

cpp:

#include "phonebook.hpp"

phonebook::person_handle_list phonebook::find(
	dept_filter p_dept,
	const std::string& s_dept,
	last_name_filter p_last_name,
	const std::string& s_last_name)
{
	person_handle_list b;
	
	
	if (p_dept == dept_equal)
	{
		auto it1 = phonebook::Department.lower_bound(s_dept);
		while (it1 != Department.end() && it1->first == s_dept)
		{
			person_handle dp = it1->second;
			b.emplace_back(dp);
			++it1;
			
		}

	}
	else if (p_dept == dept_substring)
	{
		for (auto it2 = Department.begin(); it2 != Department.end(); ++it2)
		{
			if ((it2->first).find(s_dept) != std::string::npos)
			{
				person_handle ds = it2->second;
				b.emplace_back(ds);
			}
		}
	}
	
	if (p_last_name == last_name_prefix)
	{
		for (auto it3 = LastNamePrefix.begin(); it3 != LastNamePrefix.end(); ++it3)
		{
			if ((it3->first).find(s_last_name) != std::string::npos)
			{
				person_handle ln = it3->second;
				b.emplace_back(ln);
			}
		}
	}
	b.erase(unique(b.begin(), b.end()), b.end());
	b.shrink_to_fit();
	return b;
}

const phonebook::person_entry& phonebook::get_person_entry(person_handle h) const
{

	auto a = person_hl.find(h);
	if (a == person_hl.end()) throw std::runtime_error("Invalid handle"); // osetrit*/
	
	return *a->second;
	
}

phonebook::person_handle phonebook::add_person(const person_entry& z)
{
	person_entry new_entry;
	new_entry = z;
	entries.emplace_back(new_entry);

	//auto h = entries.end()-1; // neco vymyslet
	person_handle h = quantity; ++quantity;
	LastNamePrefix.emplace(new_entry.last_name, h);
	Department.emplace(new_entry.dept, h);
	std::shared_ptr<person_entry> pp = std::make_shared<person_entry>(entries[h]);

	phonebook::person_hl.emplace(h, pp);
	//add for finding lastname and dept and handle to handle_list
	// 
	
	return h;
}

void phonebook::add_phone(person_handle h, const std::string& phone)
{
	//phonebook::person_entry ph = phonebook::get_person_entry(h);
	
	for (auto it = entries[h].phones.begin(); it != entries[h].phones.end(); ++it)
	{
		if ((*it) == phone)
			return;
	}
	entries[h].phones.push_back(phone);
}

void phonebook::remove_phone(person_handle h, const std::string& phone)
{
	//phonebook::person_entry ph = phonebook::get_person_entry(h);

	for (auto it = entries[h].phones.begin(); it != entries[h].phones.end(); ++it)
	{
		if ((*it) == phone)
		{
			entries[h].phones.erase(it);
			return;
		}	
	}
}

void phonebook::change_last_name(person_handle h, const std::string& last_name)
{
	std::string ln = entries[h].last_name;
	entries[h].last_name = last_name;
	
	auto it = phonebook::LastNamePrefix.lower_bound(ln);
	while (it != LastNamePrefix.end() && it->first == ln)
	{
		if (it->second == h)
		{
			phonebook::LastNamePrefix.erase(it);
			phonebook::LastNamePrefix.emplace(last_name, h);
			return;
		}
		++it;

	}


}

void phonebook::change_dept(person_handle h, const std::string& dept)
{
	
	std::string pd = entries[h].dept;
	entries[h].dept = dept;
	auto it = phonebook::LastNamePrefix.lower_bound(pd);
	while (it != Department.end() && it->first == pd)
	{
		if (it->second == h)
		{
			phonebook::LastNamePrefix.erase(it);
			phonebook::LastNamePrefix.emplace(pd, h);
			return;
		}
		++it;

	}

}

void phonebook::remove_person(person_handle h)
{
	for (auto it = Department.begin(); it != Department.end(); ++it)
	{
		if (it->second == h)
			Department.erase(it);
		break;
	}

	for (auto it = LastNamePrefix.begin(); it != LastNamePrefix.end(); ++it)
	{
		if (it->second == h)
			LastNamePrefix.erase(it);
		break;
	}
	
	
	person_hl.erase(h);
	++count_delete;
	if (2 * count_delete >= entries.size())
	{
		std::vector<person_entry> new_entries;
		//person_handle_list new_person_hl;
		//int j = 0;
		for (std::size_t i = 0; i < entries.size(); ++i)
		{
			if (person_hl.find(i) != person_hl.end())
			{
				new_entries.emplace_back(entries[i]);
				//new_person_hl.emplace(j, std::move(person_hl.find(i)));
				//++j;
			}

		}

		
		entries.clear(); //person_hl.clear();
		entries = std::move(new_entries);
		//person_hl(new_person_hl);
		new_entries.clear(); 
		entries.shrink_to_fit(); 
		count_delete = 0;
	}

}

/**/


test1:
/*#include "phonebook.hpp"

#include <iostream>

void dump( const phonebook & s, const phonebook::person_handle_list & b)
{
	for ( auto it = b.begin(); it != b.end(); ++ it)
	{
		phonebook::person_handle h = * it;
		const phonebook::person_entry & a = s.get_person_entry( h);
		std::cout << a.first_name << " " << a.last_name << " " << a.dept;
		for ( auto it2 = a.phones.begin();
			it2 != a.phones.end();
			++ it2)
		{
			std::cout << " " << * it2;
		}
		std::cout << std::endl;
	}
}


int main( int argc, char * * argv)
{
	phonebook s;

	{
		phonebook::person_entry z;

		z.first_name = "Melinda";
		z.last_name = "French";
		z.dept = "Marketing";
		z.phones.push_back( "4271");
		z.phones.push_back( "4323");

		phonebook::person_handle h2 = s.add_person(z);
		phonebook::person_handle h3 = s.add_person(z);

		phonebook::person_entry z1;

		z1.first_name = "Linda";
		z1.last_name = "Branch";
		z1.dept = "Mar";
		z1.phones.push_back("4278");
		z1.phones.push_back("1323");

		phonebook::person_handle h4 = s.add_person(z1);
		z1.last_name = "Brah";
		phonebook::person_handle h5 = s.add_person(z1);



	}
	

	phonebook::person_handle_list b = s.find( 
		phonebook::dept_equal, "Marketing", 
		phonebook::last_name_prefix, "Fr");

	dump( s, b);

	if (b.begin() != b.end())
	{
		phonebook::person_handle h = *b.begin();
		s.add_phone(h, "4111");
		s.remove_phone(h, "4323");
		s.change_last_name(h, "Gates");
		s.change_dept(h, "HR");
	}
	else
	{
		std::cout << "Not found" << std::endl;
	}

	

	phonebook::person_handle_list b2 = s.find( 
		phonebook::dept_substring, "Mar",
		phonebook::any_last_name, "");
	std::cout << "second dump" << std::endl;
	dump( s, b2);

	if (b.begin() != b.end())
	{
		phonebook::person_handle h = *b.begin();
		

		s.remove_person(h);
		

	}



	return 0;
}
*/


////
Result dept_substring: N=158 checksum=lgrv
Result last_name_prefix: N=17 checksum=gann
Result dept_substring+last_name_prefix: N=38 checksum=gaon

