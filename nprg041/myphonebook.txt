cpp:
#include "phonebook.hpp"

phonebook::person_handle_list phonebook::find(
	dept_filter p_dept,
	const std::string& s_dept,
	last_name_filter p_last_name,
	const std::string& s_last_name)
{
	person_handle_list b;

	switch (p_last_name)
	{
	case phonebook::any_last_name:
	{
		switch (p_dept)
		{
		case phonebook::any_dept:
		{
			for (auto it = LastNamePrefix.begin(); it != LastNamePrefix.end(); ++it)
			{
				b.emplace_back(it->second);
			}
			break;
		}
		case phonebook::dept_equal:
		{
			for (auto it = Department.lower_bound(s_dept); it != Department.end(); ++it)
			{
				b.emplace_back(it->second);
			}
			break;
		}
		case phonebook::dept_substring:
		{
			for (auto it = Department.begin(); it != Department.end(); ++it)
			{
				if (it->first.find(s_dept) != std::string::npos)
				{
					b.emplace_back(it->second);
				}
			}
			break;
		}
		default:
			break;
		}
		break;
	}
	case phonebook::last_name_prefix:
	{
		switch (p_dept)
		{
		case phonebook::any_dept:
		{

			for (auto it = LastNamePrefix.begin(); it != LastNamePrefix.end(); ++it)
			{
				if (it->first.find(s_last_name) == 0)
				{
					b.emplace_back(it->second);
				}
			}
			break;
		}
		case phonebook::dept_equal:
		{

			for (auto it = Department.lower_bound(s_dept); it != Department.end(); ++it)
			{
				if (it->first == s_dept && (it->second->last_name).find(s_last_name) == 0)
				{
					b.emplace_back(it->second);
				}
			}
			break;
		}
		case phonebook::dept_substring:
		{
			for (auto it = Department.begin(); it != Department.end(); ++it)
			{
				if (it->first.find(s_dept) != std::string::npos && (it->second->last_name).find(s_last_name) == 0)
				{
					b.emplace_back(it->second);
				}
			}
			break;
		}
		default: break;
		}
		break;
	}
	default:
		break;

	}
	return b;
}


bool phonebook::handle_exists(phonebook::person_handle h)
{
	auto dept_p = Department.find(h->dept);
	if (dept_p != Department.end())
	{
		for (auto it = dept_p->second.begin(); it != Department.end(); ++it)
		{
			if (it->second == h) return true;

		}

	}
	return false;
}
const phonebook::person_entry& phonebook::get_person_entry(person_handle h) const
{
	auto dept_p = Department.lower_bound(h->dept);
	if (dept_p != Department.end())
	{
		auto it = dept_p;
		while ((it != Department.end()) && it->first == h->dept)
		{
			if (it->second == h)
			{
				return *it->second;
			}
			++it;
		}
	}
	throw std::runtime_error("Invalid handle");
}

phonebook::person_handle phonebook::add_person(const person_entry& z)
{
	std::shared_ptr<person_entry> p = std::make_shared<person_entry>(z);


	auto it_ln = LastNamePrefix.find(z.last_name);
	if (it_ln != LastNamePrefix.end())
	{
		it_ln->second.emplace_back(std::move(p));
	}




	
	return p;
}

void phonebook::add_phone(person_handle h, const std::string& phone)
{
	if (handle_exists(h))
	{
		for (auto it = h->phones.begin(); it != h->phones.end(); ++it)
		{
			if (phone == *it) return;
		}
		h->phones.emplace_back(phone);

	}
	else
		throw std::runtime_error("Invalid handle");

}

void phonebook::remove_phone(person_handle h, const std::string& phone)
{
	if (handle_exists(h))
	{
		for (auto it = h->phones.begin(); it != h->phones.end(); ++it)
		{
			if (phone == *it)
			{
				h->phones.erase(it);
				return;
			}
		}
	}
	throw std::runtime_error("Invalid handle");
}

void phonebook::change_last_name(person_handle h, const std::string& last_name)
{


	auto it_ln = LastNamePrefix.lower_bound(h->last_name);

	while (it_ln != LastNamePrefix.end() && it_ln->first == h->last_name)
	{
		if (it_ln->second == h)
		{
			LastNamePrefix.erase(it_ln);
			h->last_name = last_name;
			LastNamePrefix.emplace(last_name, h);
			return;
		}
		++it_ln;
	}


}

void phonebook::change_dept(person_handle h, const std::string& dept)
{


	auto it_dp = Department.lower_bound(h->dept);

	while (it_dp != Department.end() && it_dp->first == h->dept)
	{
		if (it_dp->second == h)
		{
			Department.erase(it_dp);
			h->dept = dept;
			Department.emplace(dept, h);
			return;
		}
		++it_dp;
	}

}

void phonebook::remove_person(person_handle h)
{
	auto it_dp = Department.lower_bound(h->dept);
	if (it_dp != Department.end())
	{
		auto it = it_dp;
		while (it != Department.end() && it->first == h->dept)
		{
			if (it->second == h)
			{
				Department.erase(it);
				break;
			}
			++it;
		}
		auto it_ln = LastNamePrefix.lower_bound(h->last_name);
		if (it_ln != LastNamePrefix.end())
		{
			auto it = it_ln;
			while (it != LastNamePrefix.end() && it->first == h->last_name)
			{
				if (it->second == h)
				{
					LastNamePrefix.erase(it);
					return;
				}
				++it;
			}
		}

	}
	throw std::runtime_error("Invalid handle");

}

/**/

hpp:


#ifndef phonebook_hpp_
#define phonebook_hpp_

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <algorithm>
#include <deque>
#include <list>
#include <sstream>
#include <iomanip>
#include <functional>
#include <unordered_set>
#include <cstdlib>
#include <set>
#include <memory>
#include <cstring>
#include <unordered_map>


class phonebook
{
public:
	struct person_entry
	{
		~person_entry() {};
		using phone_list = std::deque<std::string>;

		std::string first_name;
		std::string last_name;
		std::string dept;
		phone_list phones;
	};

	using person_handle = std::shared_ptr<person_entry>;

	using person_handle_list = std::deque<person_handle>;
	//


	using Last_names = std::map<std::string, person_handle_list>;
	Last_names LastNamePrefix;

	std::unordered_map<std::string, Last_names> Department;


	//
	enum dept_filter 
	{
		any_dept,
		dept_equal,
		dept_substring
	};

	enum last_name_filter
	{
		any_last_name,
		last_name_prefix
	};

	person_handle_list find(
		dept_filter p_dept,
		const std::string& s_dept,
		last_name_filter p_last_name,
		const std::string& s_last_name);

	bool handle_exists(person_handle h);

	const person_entry& get_person_entry(person_handle h) const;

	person_handle add_person(const person_entry& z);

	void add_phone(person_handle h, const std::string& phone);

	void remove_phone(person_handle h, const std::string& phone);

	void change_last_name(person_handle h, const std::string& last_name);

	void change_dept(person_handle h, const std::string& dept);

	void remove_person(person_handle h);
};

#endif